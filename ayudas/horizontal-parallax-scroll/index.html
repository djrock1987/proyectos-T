<!DOCTYPE html>
<html lang="en">
<!--GENERATED BY:  Lectora Inspire v.17.1.3(11276) (http://www.trivantis.com) -->
<!--TITLE: C:\Users\Darrel\Desktop\NEW Web Support Files\jQuery -->


<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Page 1</title>

<link rel="stylesheet" href="trivantis.css" type="text/css" />
<link rel="stylesheet" href="dialog.css" type="text/css" />
<style type="text/css">
  body { background-color:#ffffff; }
</style>

<!--[if lte IE 9]>
<script>
document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', "#default#VML")
</script>
<![endif]-->

<script src="trivantis.js"></script>
<script src="trivantis-timedate.js"></script>
<script src="es6-promise-2.0.0.min.js"></script>
<script src="jquery-1.10.2.min.js"></script>
<script src="trivantis-cookie.js"></script>
<script src="trivantis-image.js"></script>
<script src="trivantis-pagetracking.js"></script>
<script src="trivantis-dialog.js"></script>
<script src="trivantis-strings.js" charset="UTF-8"></script>
<script>

<!-- 
var trivPageScope = {};
var pgID = 'page2';
trivWeb20Popups = true;
var bPageLoaded = false;
var bDisableBrowserResize = (null);
var bScaleToWindow = false;
var bFitToWidth = false;
var pageHeight = 662;
var bLoadedVariables = false;

var arObjs = [];
if( !is.min )
  document.write( 'Your browser does not support dynamic html. Please download a current version of either <a href="http://www.microsoft.com/ie/">Microsoft Internet Explorer</a> or <a href="http://www.mozilla.com/en-US/firefox/">Mozilla Firefox </a> and try visiting our site again.  Thank You.<br /><br />' )

var pageLayer = null
var winW = getDisplayWindow().screen.width
var winH = getDisplayWindow().screen.height
var transformScale = 1

function findWH(){	//echo LD-769
	if (is.ie9) {
	var vScrollAdj =  (is.ns ? 16 : 20);
	winW = (is.ns) ? window.innerWidth - vScrollAdj : document.body.offsetWidth;
	winH = (is.ns) ? window.innerHeight : document.body.offsetHeight;
	}
	else if (is.ie) {
   winW = Math.max(Math.max(getDisplayDocument().body.scrollWidth, getDisplayDocument().documentElement.scrollWidth)-16,
					  Math.max(getDisplayDocument().body.offsetWidth, getDisplayDocument().documentElement.offsetWidth)-16,
					  Math.max(getDisplayDocument().body.clientWidth, getDisplayDocument().documentElement.clientWidth)-16 );
   winH = Math.max(Math.max(getDisplayDocument().body.scrollHeight, getDisplayDocument().documentElement.scrollHeight)-16,
					  Math.max(getDisplayDocument().body.offsetHeight, getDisplayDocument().documentElement.offsetHeight)-16,
					  Math.max(getDisplayDocument().body.clientHeight, getDisplayDocument().documentElement.clientHeight)-16 );
	}
	else
	{
   winW =  getDisplayDocument().documentElement.clientWidth ? getDisplayDocument().documentElement.clientWidth : getDisplayDocument().body.clientWidth;
   if(is.iOS && (navigator.userAgent.indexOf('CellCast-iPad') != -1 || navigator.userAgent.indexOf('CellCast-iPhone') != -1) )
		 winW =  getScreenWidth();
   winH =  getDisplayDocument().documentElement.clientHeight ? getDisplayDocument().documentElement.clientHeight : getDisplayDocument().body.clientHeight;
	}
}

trivSetupPage();

function ReFlow() {
  findWH()
  var left = (winW > 3009) ? (winW-3009)/2 : 0
  if (pageLayer)
  {
    pageLayer.moveTo( left, 0 );
    if(!bScaleToWindow)
    pageLayer.hasMoved = true;
    pageLayer.newX = left;
    pageLayer.newY = 0;
   fillBrowser();
   adjustAllObjectsForFixedPosition();
   setfixed();
 }
}


VarTrivSelCap = new Variable( 'VarTrivSelCap', 'none', 0, 0, null, null, 'horizontal_parallax_scroll', true )

onload = init
if( is.webkit && !is.iOSSafari )
  onbeforeunload = finish
else
  onunload = finish

function init() {
  if(is.ie8)
    trivAlert('2', 'horizontal parallax scroll', 'Some features may not properly appear in older Web browsers. Upgrading to a current browser is recommended. Contact your course administrator if you have questions.', 'init11()');
  else
    init11();
}

function init11() {
  findWH()
  if( is.min ){
    trivPageTracking.InitPageTracking();
    PreloadResources(new Array(shape57,shape73,shape289,shape673))
    pageLayer = new ObjLayer(GetCurrentPageID());
    pageLayer.show(true);
    shape57.init()
    shape73.init()
    shape289.init()
    shape673.init()
    shape57.activate()
    shape73.activate()
    shape289.activate()
    shape673.activate()
    window.scrollTo(0,1);
    var titleManagerIndexWindow = (window && window.parent && window.parent.bIsTitleManagerIndexFile) ? window.parent : null;
    if(titleManagerIndexWindow)titleManagerIndexWindow.scrollTo(0,1);
    action147(  );

    if(!isSinglePagePlayerAvail()) postPageShowAction();
    if( location.hash )
    {
      var newHash
      if( location.hash.charAt(0) == '#' )
        newHash = location.hash.slice( 1 )
      else
        newHash = location.hash
      location.hash = newHash
      if((typeof(bTrivRunView) != 'undefined'  && bTrivRunView) || (typeof(bTrivOffline) != 'undefined' && bTrivOffline)) window.scrollTo(0 , getTopofObj(document.getElementById(newHash)));
    }
    setTimeout( 'trivUpdateTOC( 1 )', 100 )
    bPageLoaded = true;
    ReFlow();
  }
}
function postPageShowAction(){
  if ( trivPageTracking.GetRangeStatus(2) == 'notstarted' ) trivPageTracking.SetRangeStatus(2,2);
}  

var trivGoToPage = null
var trivCompleteCnt = 1;
var hasProcessedExitActions = false;
var trivActFBCnt = 0;
var currFeedbackIdx = 0;
var trivPageExited = false;
var trivInTest = false;

function finish() {
}

function trivOnFocus() {
    if( trivPageExited ) return
}

function checkLeavePage() {
    if( trivPageExited ) return
    if( trivActFBCnt == 0 )
    {
        currFeedbackIdx++;
        if( currFeedbackIdx > -1)
        {
            trivLeavePage();
          return;
        }
        else if( !checkQuestions( true ))
          return;
    }
    setTimeout( 'checkLeavePage()', 100)
}

function trivExitPage( newPage, bFeedback ) {
    if( newPage.indexOf( "ObjLayerAction" ) >= 0 || newPage.indexOf( "javascript:app." ) >= 0 || newPage.indexOf( ".action" ) >= 0 || newPage.indexOf( "history.back()" ) >= 0) trivGoToPage = newPage
    else trivGoToPage = 'ObjLayerActionGoTo("' + newPage + '")'
    if( !hasProcessedExitActions ) {
        findWH()
        hasProcessedExitActions = true
        setTimeout( 'checkLeavePage()', 100)
    }
}

function trivLeavePage() {
    trivCompleteCnt--
    if( trivCompleteCnt <= 0 ) {
        hasProcessedExitActions = false
        if( trivGoToPage != null )
        {
			eval( trivGoToPage )
			trivGoToPage = null;
			if( window.closed ) trivPageExited = true;
        }
    }
}

function trivPrevPage() {
}

function trivNextPage() {
}

function trivUpdateTOC( bRecurse ) {
    var i
}

function trivUpdateEntry() {
}

function trivResetEntry(entFld) {
}

function OnDeviceRotate() {

}

// ------------------------------------------
// Rellax.js
// Buttery smooth parallax library
// Copyright (c) 2016 Moe Amaya (@moeamaya)
// MIT license
//
// Thanks to Paraxify.js and Jaime Cabllero
// for parallax concepts
// ------------------------------------------
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.Rellax = factory();
  }
}(this, function () {
  var Rellax = function(el, options){
    "use strict";
    var self = Object.create(Rellax.prototype);
    var posY = 0;
    var screenY = 0;
    var posX = 0;
    var screenX = 0;
    var blocks = [];
    var pause = true;
    // check what requestAnimationFrame to use, and if
    // it's not supported, use the onscroll event
    var loop = window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      function(callback){ setTimeout(callback, 1000 / 60); };
    // check which transform property to use
    var transformProp = window.transformProp || (function(){
        var testEl = document.createElement('div');
        if (testEl.style.transform === null) {
          var vendors = ['Webkit', 'Moz', 'ms'];
          for (var vendor in vendors) {
            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {
              return vendors[vendor] + 'Transform';
            }
          }
        }
        return 'transform';
      })();
    // Default Settings
    self.options = {
      speed: -2,
      center: false,
      wrapper: null,
      round: true,
      vertical: true,
      horizontal: false,
      callback: function() {},
    };
    // User defined options (might have more in the future)
    if (options){
      Object.keys(options).forEach(function(key){
        self.options[key] = options[key];
      });
    }
    // By default, rellax class
    if (!el) {
      el = '.rellax';
    }
    // check if el is a className or a node
    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];
    // Now query selector
    if (elements.length > 0) {
      self.elems = elements;
    }
    // The elements don't exist
    else {
      throw new Error("The elements you're trying to select don't exist.");
    }
    // Has a wrapper and it exists
    if (self.options.wrapper) {
      if (!self.options.wrapper.nodeType) {
        var wrapper = document.querySelector(self.options.wrapper);
        if (wrapper) {
          self.options.wrapper = wrapper;
        } else {
          throw new Error("The wrapper you're trying to use don't exist.");
        }
      }
    }
    // Get and cache initial position of all elements
    var cacheBlocks = function() {
      for (var i = 0; i < self.elems.length; i++){
        var block = createBlock(self.elems[i]);
        blocks.push(block);
      }
    };
    // Let's kick this script off
    // Build array for cached element values
    var init = function() {
      for (var i = 0; i < blocks.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }
      blocks = [];
      screenY = window.innerHeight;
      screenX = window.innerWidth;
      setPosition();
      cacheBlocks();
      // If paused, unpause and set listener for window resizing events
      if (pause) {
        window.addEventListener('resize', init);
        pause = false;
      }
      animate();
    };
    // We want to cache the parallax blocks'
    // values: base, top, height, speed
    // el: is dom object, return: el cache values
    var createBlock = function(el) {
      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );
      var dataSpeed = el.getAttribute( 'data-rellax-speed' );
      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;
      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)
      // ensures elements are positioned based on HTML layout.
      //
      // If the element has the percentage attribute, the posY and posX needs to be
      // the current scroll position's value, so that the elements are still positioned based on HTML layout
      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);
      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;
      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;
      var blockTop = posY + el.getBoundingClientRect().top;
      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;
      var blockLeft = posX + el.getBoundingClientRect().left;
      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;
      // apparently parallax equation everyone uses
      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);
      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);
      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }
      // Optional individual block speed as data attr, otherwise global speed
      var speed = dataSpeed ? dataSpeed : self.options.speed;
      var bases = updatePosition(percentageX, percentageY, speed);
      // ~~Store non-translate3d transforms~~
      // Store inline styles and extract transforms
      var style = el.style.cssText;
      var transform = '';
      // Check if there's an inline styled transform
      if (style.indexOf('transform') >= 0) {
        // Get the index of the transform
        var index = style.indexOf('transform');
        // Trim the style to the transform point and get the following semi-colon index
        var trimmedStyle = style.slice(index);
        var delimiter = trimmedStyle.indexOf(';');
        // Remove "transform" string and save the attribute
        if (delimiter) {
          transform = " " + trimmedStyle.slice(11, delimiter).replace(/\s/g,'');
        } else {
          transform = " " + trimmedStyle.slice(11).replace(/\s/g,'');
        }
      }
      return {
        baseX: bases.x,
        baseY: bases.y,
        top: blockTop,
        left: blockLeft,
        height: blockHeight,
        width: blockWidth,
        speed: speed,
        style: style,
        transform: transform,
        zindex: dataZindex
      };
    };
    // set scroll position (posY, posX)
    // side effect method is not ideal, but okay for now
    // returns true if the scroll changed, false if nothing happened
    var setPosition = function() {
      var oldY = posY;
      var oldX = posX;
      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;
      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;
      if (oldY != posY && self.options.vertical) {
        // scroll changed, return true
        return true;
      }
      if (oldX != posX && self.options.horizontal) {
        // scroll changed, return true
        return true;
      }
      // scroll did not change
      return false;
    };
    // Ahh a pure function, gets new transform value
    // based on scrollPosition and speed
    // Allow for decimal pixel values
    var updatePosition = function(percentageX, percentageY, speed) {
      var result = {};
      var valueX = (speed * (100 * (1 - percentageX)));
      var valueY = (speed * (100 * (1 - percentageY)));
      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;
      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;
      return result;
    };
    // Loop
    var update = function() {
      if (setPosition() && pause === false) {
        animate();
      }
      // loop again
      loop(update);
    };
    // Transform3d on parallax element
    var animate = function() {
      var positions;
      for (var i = 0; i < self.elems.length; i++){
        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));
        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));
        // Subtracting initialize value, so element stays in same spot as HTML
        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;
        var positionY = positions.y - blocks[i].baseY;
        var positionX = positions.x - blocks[i].baseX;
        var zindex = blocks[i].zindex;
        // Move that element
        // (Set the new translation and append initial inline transforms.)
        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;
        self.elems[i].style[transformProp] = translate;
      }
      self.options.callback(positions);
    };
    self.destroy = function() {
      for (var i = 0; i < self.elems.length; i++){
        self.elems[i].style.cssText = blocks[i].style;
      }
      // Remove resize event listener if not pause, and pause
      if (!pause) {
        window.removeEventListener('resize', init);
        pause = true;
      }
    };
    // Init
    init();
    // Start the loop
    update();
    // Allow to recalculate the initial values whenever we want
    self.refresh = init;
    return self;
  };
  return Rellax;
}));

function action147(fn){
    try{
       var rellax = new Rellax('.rellax', {
    speed: -10,
    vertical: false,
    horizontal: true,
  });


  var rellax2 = new Rellax('.rellax2', {
    speed: -7,
    vertical: false,
    horizontal: true,
  });

  var rellax3 = new Rellax('.rellax3', {
    speed: -4,
    vertical: false,
    horizontal: true,
  });
     } catch (e) {
     alert('[OnShowRunJS] ' + e);
     }
    if(fn && typeof(fn) == 'string' ) eval(fn);
    else if(fn && typeof(fn) == 'function' ) fn();
}

if( is.min ){
shape57 = new ObjImage('shape57','images/shape57.png','Red Diamond',765,9,160.000000,160.000000,1,2,'div','',0 ,'rellax')
shape57.initRotateAngle(0,0,0,-0.000000,-0.000000,159,159)
shape57.initHasShadow(0)
shape57.initHasReflection(0)
shape57.setUniqueFillID('index_shape57')
shape57.addIe8Attr(765.000000, 9.000000, 160.000000, 160.000000, 0, 0)
shape57.initImageMap(1,'79,1,158,79,79,158,1,79,79,1','M 79.000000 1.000000 L 158.000000 79.000000 L 79.000000 158.000000 L 1.000000 79.000000 L 79.000000 1.000000 z', '', 'stroke:#000000; stroke-width:2; stroke-linejoin:round;stroke-dasharray: none; fill:#CC0000;"' , '')
shape57.setTextVal('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAB7SURBVHhe7cExAQAAAMKg9U9tDQ8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADtQAkK8AAT0JXwIAAAAASUVORK5CYII=' , 'fill:url(#Text_index_shape57)')
shape57.setUseSvgFile(1)
shape57.addBorder(0)
shape57.initLineWeight(2)
shape57.addOpacity(100)
shape57.build()

shape73 = new ObjImage('shape73','images/shape73.png','Yellow Diamond',765,172,160.000000,160.000000,1,3,'div','',0 ,'rellax2')
shape73.initRotateAngle(0,0,0,-0.000000,-0.000000,159,159)
shape73.initHasShadow(0)
shape73.initHasReflection(0)
shape73.setUniqueFillID('index_shape73')
shape73.addIe8Attr(765.000000, 172.000000, 160.000000, 160.000000, 0, 0)
shape73.initImageMap(1,'79,1,158,79,79,158,1,79,79,1','M 79.000000 1.000000 L 158.000000 79.000000 L 79.000000 158.000000 L 1.000000 79.000000 L 79.000000 1.000000 z', '', 'stroke:#000000; stroke-width:2; stroke-linejoin:round;stroke-dasharray: none; fill:#FFFF00;"' , '')
shape73.setTextVal('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAB7SURBVHhe7cExAQAAAMKg9U9tDQ8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADtQAkK8AAT0JXwIAAAAASUVORK5CYII=' , 'fill:url(#Text_index_shape73)')
shape73.setUseSvgFile(1)
shape73.addBorder(0)
shape73.initLineWeight(2)
shape73.addOpacity(100)
shape73.build()

shape289 = new ObjImage('shape289','images/shape289.png','Green Diamond',765,336,160.000000,160.000000,1,4,'div','',0 ,'rellax3')
shape289.initRotateAngle(0,0,0,-0.000000,-0.000000,159,159)
shape289.initHasShadow(0)
shape289.initHasReflection(0)
shape289.setUniqueFillID('index_shape289')
shape289.addIe8Attr(765.000000, 336.000000, 160.000000, 160.000000, 0, 0)
shape289.initImageMap(1,'79,1,158,79,79,158,1,79,79,1','M 79.000000 1.000000 L 158.000000 79.000000 L 79.000000 158.000000 L 1.000000 79.000000 L 79.000000 1.000000 z', '', 'stroke:#000000; stroke-width:2; stroke-linejoin:round;stroke-dasharray: none; fill:#009E0F;"' , '')
shape289.setTextVal('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAB7SURBVHhe7cExAQAAAMKg9U9tDQ8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADtQAkK8AAT0JXwIAAAAASUVORK5CYII=' , 'fill:url(#Text_index_shape289)')
shape289.setUseSvgFile(1)
shape289.addBorder(0)
shape289.initLineWeight(2)
shape289.addOpacity(100)
shape289.build()

shape673 = new ObjImage('shape673','images/shape673.png','White Diamond',765,503,160.000000,160.000000,1,5,'div','',0 )
shape673.initRotateAngle(0,0,0,-0.000000,-0.000000,159,159)
shape673.initHasShadow(0)
shape673.initHasReflection(0)
shape673.setUniqueFillID('index_shape673')
shape673.addIe8Attr(765.000000, 503.000000, 160.000000, 160.000000, 0, 0)
shape673.initImageMap(1,'79,1,158,79,79,158,1,79,79,1','M 79.000000 1.000000 L 158.000000 79.000000 L 79.000000 158.000000 L 1.000000 79.000000 L 79.000000 1.000000 z', '', 'stroke:#000000; stroke-width:2; stroke-linejoin:round;stroke-dasharray: none; fill:#FFFFFF;"' , '')
shape673.setTextVal('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAACgCAYAAACLz2ctAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAB7SURBVHhe7cExAQAAAMKg9U9tDQ8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADtQAkK8AAT0JXwIAAAAASUVORK5CYII=' , 'fill:url(#Text_index_shape673)')
shape673.setUseSvgFile(1)
shape673.addBorder(0)
shape673.initLineWeight(2)
shape673.addOpacity(100)
shape673.build()

arObjs.push(shape57);
arObjs.push(shape73);
arObjs.push(shape289);
arObjs.push(shape673);


writeStyleSheets(arObjs);}
// -->

</script>
</head>

<body onfocus="trivOnFocus()" onResize="ReFlow()">

   <DIV id="pageDIV" >
   </DIV>
<script>
if( is.min ){
    findWH()
    var left = (winW > 3009) ? (winW-3009)/2 : 0
    document.write('<style type="text/css">#pageDIV { position: absolute; top:0px; left: ' + left + 'px; width:3009px; height:662px; clip:rect(0px 3009px 662px 0px); overflow:hidden;' )
    if(is.iOS)
		document.write('-webkit-text-size-adjust:100%;')
    document.write('layer-background-image: url(images/nasa3.jpg); background-image: url(images/nasa3.jpg); background-repeat:repeat-x;' )
    document.write('} </style>')
}
</script>

<script>
if( is.min ){
    appendElement(shape57, null, null);
    appendElement(shape73, null, null);
    appendElement(shape289, null, null);
    appendElement(shape673, null, null);
}
</script>

</body>
</html>
